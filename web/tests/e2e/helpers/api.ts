import { APIRequestContext } from '@playwright/test';

/**
 * API Helper Functions for E2E Tests
 *
 * Purpose: Provide reusable API interaction helpers
 * Framework: Agentic QE with Playwright
 */

/**
 * Backend API configuration
 */
export const API_CONFIG = {
  baseURL: process.env.API_BASE_URL || 'http://localhost:8080',
  version: 'v1',
};

/**
 * Get the full API endpoint URL
 */
export function getApiUrl(path: string): string {
  const cleanPath = path.startsWith('/') ? path.slice(1) : path;
  return `${API_CONFIG.baseURL}/api/${API_CONFIG.version}/${cleanPath}`;
}

/**
 * Get SIWE nonce from backend
 *
 * @param request - Playwright request context
 * @returns Promise<string> - The nonce value
 */
export async function getNonce(request: APIRequestContext): Promise<string> {
  try {
    const response = await request.get(getApiUrl('auth/nonce'));

    if (!response.ok()) {
      throw new Error(`Failed to get nonce: ${response.status()} ${response.statusText()}`);
    }

    const data = await response.json();

    if (!data.nonce) {
      throw new Error('Nonce not found in response');
    }

    return data.nonce;
  } catch (error) {
    console.error('Error getting nonce:', error);
    throw error;
  }
}

/**
 * Verify SIWE signature and get JWT token
 *
 * @param request - Playwright request context
 * @param message - SIWE message that was signed
 * @param signature - Wallet signature
 * @param address - Ethereum address
 * @returns Promise<string> - JWT token
 */
export async function verifySignature(
  request: APIRequestContext,
  message: string,
  signature: string,
  address: string
): Promise<string> {
  try {
    const response = await request.post(getApiUrl('auth/verify'), {
      data: {
        message,
        signature,
        address,
      },
    });

    if (!response.ok()) {
      throw new Error(`Failed to verify signature: ${response.status()} ${response.statusText()}`);
    }

    const data = await response.json();

    if (!data.token) {
      throw new Error('JWT token not found in response');
    }

    return data.token;
  } catch (error) {
    console.error('Error verifying signature:', error);
    throw error;
  }
}

/**
 * Generate a test JWT token (for mocking)
 *
 * Note: This creates a mock token for testing purposes only
 * In production, tokens are generated by the backend
 *
 * @param address - Ethereum address
 * @returns string - Mock JWT token
 */
export function generateJWT(address: string): string {
  const header = btoa(JSON.stringify({ alg: 'HS256', typ: 'JWT' }));
  const payload = btoa(
    JSON.stringify({
      address,
      iat: Math.floor(Date.now() / 1000),
      exp: Math.floor(Date.now() / 1000) + 86400, // 24 hours
    })
  );
  const signature = 'mock_signature_for_testing';

  return `${header}.${payload}.${signature}`;
}

/**
 * Create an API key
 *
 * @param request - Playwright request context
 * @param token - JWT authentication token
 * @param name - API key name
 * @param scopes - Array of scope strings
 * @returns Promise<object> - Created API key data
 */
export async function createAPIKey(
  request: APIRequestContext,
  token: string,
  name: string,
  scopes: string[]
): Promise<any> {
  try {
    const response = await request.post(getApiUrl('api-keys'), {
      headers: {
        Authorization: `Bearer ${token}`,
      },
      data: {
        name,
        scopes,
      },
    });

    if (!response.ok()) {
      throw new Error(`Failed to create API key: ${response.status()} ${response.statusText()}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error creating API key:', error);
    throw error;
  }
}

/**
 * List all API keys for authenticated user
 *
 * @param request - Playwright request context
 * @param token - JWT authentication token
 * @returns Promise<array> - List of API keys
 */
export async function listAPIKeys(
  request: APIRequestContext,
  token: string
): Promise<any[]> {
  try {
    const response = await request.get(getApiUrl('api-keys'), {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });

    if (!response.ok()) {
      throw new Error(`Failed to list API keys: ${response.status()} ${response.statusText()}`);
    }

    const data = await response.json();
    return data.apiKeys || data.keys || data || [];
  } catch (error) {
    console.error('Error listing API keys:', error);
    throw error;
  }
}

/**
 * Delete/revoke an API key
 *
 * @param request - Playwright request context
 * @param token - JWT authentication token
 * @param keyId - API key ID to delete
 * @returns Promise<boolean> - Success status
 */
export async function deleteAPIKey(
  request: APIRequestContext,
  token: string,
  keyId: string
): Promise<boolean> {
  try {
    const response = await request.delete(getApiUrl(`api-keys/${keyId}`), {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });

    if (!response.ok() && response.status() !== 204) {
      throw new Error(`Failed to delete API key: ${response.status()} ${response.statusText()}`);
    }

    return true;
  } catch (error) {
    console.error('Error deleting API key:', error);
    throw error;
  }
}

/**
 * Get API key details
 *
 * @param request - Playwright request context
 * @param token - JWT authentication token
 * @param keyId - API key ID
 * @returns Promise<object> - API key details
 */
export async function getAPIKey(
  request: APIRequestContext,
  token: string,
  keyId: string
): Promise<any> {
  try {
    const response = await request.get(getApiUrl(`api-keys/${keyId}`), {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });

    if (!response.ok()) {
      throw new Error(`Failed to get API key: ${response.status()} ${response.statusText()}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error getting API key:', error);
    throw error;
  }
}

/**
 * Test an API key by making an authenticated request
 *
 * @param request - Playwright request context
 * @param apiKey - The API key to test
 * @returns Promise<boolean> - Whether the API key is valid
 */
export async function testAPIKey(
  request: APIRequestContext,
  apiKey: string
): Promise<boolean> {
  try {
    const response = await request.get(getApiUrl('user/profile'), {
      headers: {
        'X-API-Key': apiKey,
      },
    });

    return response.ok();
  } catch (error) {
    console.error('Error testing API key:', error);
    return false;
  }
}

/**
 * Wait for backend to be ready
 *
 * @param request - Playwright request context
 * @param maxAttempts - Maximum number of retry attempts
 * @param delayMs - Delay between attempts in milliseconds
 * @returns Promise<boolean> - Whether backend is ready
 */
export async function waitForBackend(
  request: APIRequestContext,
  maxAttempts: number = 30,
  delayMs: number = 1000
): Promise<boolean> {
  for (let i = 0; i < maxAttempts; i++) {
    try {
      const response = await request.get(getApiUrl('health'));
      if (response.ok()) {
        return true;
      }
    } catch (error) {
      // Backend not ready yet
    }

    await new Promise(resolve => setTimeout(resolve, delayMs));
  }

  return false;
}

/**
 * Create SIWE message
 *
 * @param address - Ethereum address
 * @param nonce - SIWE nonce
 * @param chainId - Chain ID (default: 1 for mainnet)
 * @returns string - SIWE message
 */
export function createSIWEMessage(
  address: string,
  nonce: string,
  chainId: number = 1
): string {
  const domain = 'localhost:3000';
  const uri = 'http://localhost:3000';
  const version = '1';
  const issuedAt = new Date().toISOString();

  return `${domain} wants you to sign in with your Ethereum account:
${address}

Welcome to Gatekeeper - Sign in to authenticate

URI: ${uri}
Version: ${version}
Chain ID: ${chainId}
Nonce: ${nonce}
Issued At: ${issuedAt}`;
}

/**
 * Parse JWT token payload
 *
 * @param token - JWT token string
 * @returns object - Decoded payload
 */
export function parseJWT(token: string): any {
  try {
    const [, payloadBase64] = token.split('.');
    const payload = atob(payloadBase64);
    return JSON.parse(payload);
  } catch (error) {
    console.error('Error parsing JWT:', error);
    return null;
  }
}

/**
 * Check if JWT token is expired
 *
 * @param token - JWT token string
 * @returns boolean - Whether token is expired
 */
export function isJWTExpired(token: string): boolean {
  const payload = parseJWT(token);

  if (!payload || !payload.exp) {
    return true;
  }

  const expirationTime = payload.exp * 1000; // Convert to milliseconds
  return Date.now() >= expirationTime;
}

/**
 * Mock API response interceptor
 *
 * @param page - Playwright page
 * @param endpoint - API endpoint to mock
 * @param responseData - Mock response data
 * @param statusCode - HTTP status code
 */
export async function mockAPIResponse(
  page: any,
  endpoint: string,
  responseData: any,
  statusCode: number = 200
) {
  await page.route(`**/${endpoint}`, route => {
    route.fulfill({
      status: statusCode,
      contentType: 'application/json',
      body: JSON.stringify(responseData),
    });
  });
}

/**
 * Clear all API route mocks
 *
 * @param page - Playwright page
 */
export async function clearAPIMocks(page: any) {
  await page.unroute('**/api/**');
}
